Listing:

   1 MODULE RegexMatching;
   2 
   3 IMPORT RegexParser, texts, Console;
   4 
   5 TYPE Regex=POINTER TO EXTENSIBLE RECORD (RegexParser.RegexType) END;
   6 
   7 VAR i:INTEGER;
   8         
   9         rch:texts.RichChar;
  10         (*tarString:POINTER TO ARRAY OF CHAR;*)
  11         sh:texts.Shared;
  12         
  13 PROCEDURE WriteMessage(str:ARRAY OF CHAR);
  14 BEGIN
  15         Console.WriteString(str);
  16         Console.WriteLn;
  17 END WriteMessage;
  18                 
  19 PROCEDURE WriteEntry(fromProcedure:ARRAY OF CHAR;ch:CHAR;i:INTEGER);
  20 
  21 
  22 BEGIN   
  23         Console.WriteString(fromProcedure +" Entry:  ");                
  24         IF ch # 0X THEN Console.Write(ch);
  25         END;
  26         
  27         IF i >= 0 THEN Console.WriteString(" Position i: "); Console.WriteInt(i,2);
  28         END;
  29         Console.WriteLn();
  30 END WriteEntry;
  31 
  32 
  33 
  34 PROCEDURE WriteExit(fromProcedure:ARRAY OF CHAR;valResult:INTEGER;ch:CHAR;i:INTEGER);
  35 
  36 VAR res:ARRAY 10 OF CHAR; 
  37 BEGIN
  38         IF valResult=1  THEN res:="TRUE" ELSIF valResult=-1 THEN res:="FALSE" ELSE res:=""; END;
  39         Console.WriteString(fromProcedure +" Exit: "+res+"  ");         
  40         IF ch # 0X THEN Console.Write(ch);
  41         END;
  42         IF i >= 0 THEN Console.WriteString(" Position i: ");Console.WriteInt(i,2);
  43         END;
  44         Console.WriteLn();
  45 END WriteExit;
  46 
  47 (*-------------------------Matching Procedures---------------------------*)
  48 
  49 PROCEDURE MatchNegRange(range:RegexParser.Range; VAR flag:BOOLEAN);
  50 BEGIN
  51         WriteMessage("MatchNegRange Entry");
  52         IF sh.backTrack THEN WriteMessage("MatchNegRange backTrack");RETURN END;
  53         REPEAT
  54                 flag:=((rch.ch<range.min) OR (rch.ch>range.max));
  55                 range:=range.next;
  56         UNTIL range=NIL;
  57         WriteMessage("MatchNegRange Exit");
  58 END MatchNegRange;
  59 
  60 PROCEDURE MatchRange(range:RegexParser.Range; VAR flag:BOOLEAN);
  61 BEGIN
  62         WriteEntry("MatchRange ",rch.ch,-1);
  63         IF sh.backTrack THEN RETURN END;
  64         LOOP
  65                 IF range=NIL THEN EXIT END;
  66                 Console.WriteString("MatchRange range.min: "); 
  67                 Console.Write(range.min);
  68                 Console.WriteString(" MatchRange range.max: "); 
  69                 Console.Write(range.max);
  70                 Console.WriteLn();
  71                 flag:=((rch.ch>=range.min) & (rch.ch<=range.max));
  72                 IF flag=TRUE THEN EXIT;
  73                 ELSE range:=range.next 
  74                 END;
  75         END;
  76         (*  are there any  subRanges *)
  77         LOOP
  78                 IF range=NIL THEN EXIT END;
  79                 IF range.sub THEN EXIT END;
  80                 range:=range.next
  81         END;
  82         IF range#NIL THEN MatchNegRange(range,flag) END;
  83         
  84         WriteExit("MatchRange ch ",0,rch.ch,-1);
  85 END MatchRange; 
  86 
  87 
  88 PROCEDURE MatchChar(Ptr:POINTER TO ARRAY OF CHAR;rch:texts.RichChar):BOOLEAN;
  89 
  90 BEGIN
  91         (* TO DO *)
  92         RETURN TRUE;
  93 
  94 END MatchChar;
  95 
  96 PROCEDURE Size(regex:RegexParser.Regex; rch:texts.RichChar):BOOLEAN;
  97 BEGIN
  98         IF regex.Font.size = NIL THEN RETURN TRUE
  99         ELSE RETURN MatchChar(regex.Font.size,rch);
 100         END; 
 101 END Size;
 102 
 103 PROCEDURE Style(regex:RegexParser.Regex; rch:texts.RichChar):BOOLEAN;
 104 BEGIN
 105         IF regex.Font.style = NIL THEN RETURN TRUE
 106         ELSE RETURN MatchChar(regex.Font.style,rch);
 107         END; 
 108 END Style;
 109 
 110 PROCEDURE Typeface(regex:RegexParser.Regex; rch:texts.RichChar):BOOLEAN;
 111 BEGIN
 112         IF regex.Font.typeface = NIL THEN RETURN TRUE
 113         ELSE RETURN MatchChar(regex.Font.typeface,rch);
 114         END; 
 115 END Typeface;
 116 
 117 PROCEDURE Weight(regex:RegexParser.Regex; rch:texts.RichChar):BOOLEAN;
 118 BEGIN
 119         IF regex.Font.weight = NIL THEN RETURN TRUE
 120         ELSE RETURN MatchChar(regex.Font.weight,rch);
 121         END; 
 122 END Weight;
 123 
 124 PROCEDURE Color(regex:RegexParser.Regex; rch:texts.RichChar):BOOLEAN;
 125 BEGIN
 126         IF regex.Font.color = NIL THEN RETURN TRUE
 127         ELSE RETURN MatchChar(regex.Font.color,rch);
 128         END; 
 129 END Color;
 130 
 131 
 132 PROCEDURE FontMatch(rch:texts.RichChar; regex:RegexParser.Regex):INTEGER;
 133 
 134         
 135 
 136 BEGIN
 137         IF regex.Font=NIL THEN RETURN 1 
 138         ELSIF Size(regex,rch) & Style(regex,rch) & Typeface(regex,rch) &  
 139                 Weight(regex,rch) & Color(regex,rch) THEN
 140                 RETURN 1 
 141         ELSE RETURN -1
 142         END;
 143 END FontMatch;
 144 
 145 
 146 PROCEDURE MatchRegex(regex:RegexParser.Regex;resetPos:INTEGER;VAR flag:BOOLEAN);
**** ---------------------^
**** Warning: This variable is accessed from nested procedure
**** ---------------------------------------------^
**** Warning: This variable is accessed from nested procedure
**** Access to variable <regex> will be inefficient
**** Access to variable <resetPos> will be inefficient
 147 VAR  branch:RegexParser.Branch;
 148                 j:INTEGER (*ResetPosition*);
 149                 res:INTEGER;
 150         
 151         PROCEDURE MatchBranch(branch:RegexParser.Branch; VAR flag:BOOLEAN);
 152         VAR piece:RegexParser.Piece;
**** ------------^ Warning: This variable is accessed from nested procedure
**** Access to variable <piece> will be inefficient
 153         res:INTEGER;
 154         
 155                 PROCEDURE MatchPiece(piece:RegexParser.Piece; VAR flag:BOOLEAN);
 156                 VAR atom,temp_atom:RegexParser.Atom;
 157                                 min,max (* nr repetitions *),
 158                                 q (*counts number matches for quantified or for '*' or '+'*),
 159                                 j1:INTEGER (* interim value for i; formerly j; is named here j1 for
 160                                 difference with j in MatchRegex *);
 161                                 temp_flag:BOOLEAN;
 162                                 res:INTEGER;
 163                                 
 164                         PROCEDURE MatchAtom(atom:RegexParser.Atom; VAR flag:BOOLEAN);
 165                         VAR range:RegexParser.Range;res:INTEGER;
 166                         
 167                                 
 168                         BEGIN (* MatchAtom *)
 169                                 WriteEntry("MatchAtom ",' ',-1);
 170                                 IF sh.backTrack THEN 
 171                                         WriteMessage("MatchAtom sh.backTrack RETURN");
 172                                         RETURN 
 173                                 END;
 174                                 IF atom.range=NIL THEN  
 175                                         WriteMessage("MatchAtom range Nil vor MatchRegex");
 176                                         MatchRegex(atom.regex,resetPos,flag);
**** Warning: Non-local variable access here-----------------------^
 177                                 ELSE    
 178                                 
 179                                         IF ~(rch.ch=0X) THEN 
 180                                                 
 181                                                 (*ch:= GetCharAtPos(i,sh);*) (* sh.getCharAtTextPos(i); *)      
 182                                                 rch := sh.getSym();
 183                                                         
 184                                                 IF sh.backTrack THEN 
 185                                                         WriteMessage("MatchAtom sh.backtrach nach getSym");
 186                                                         RETURN 
 187                                                 END;                    
 188                                                 (*INC(i);*)
 189                                                 Console.WriteString("MatchAtom getSym ch: ");
 190                                                 Console.Write(rch.ch); 
 191                                                 Console.WriteLn();
 192                                         END;                    
 193                                         IF atom.range.pos THEN
 194                                                 WriteMessage("MatchAtom range.pos vor MatchRange");
 195                                                 MatchRange(atom.range,flag); 
 196                                         ELSE 
 197                                                 WriteMessage("MatchAtom vor MatchNegRange");
 198                                                 MatchNegRange(atom.range,flag);
 199                                         END;
 200                                 
 201                                 END;
 202                                 IF flag THEN 
 203                                         res:= FontMatch(rch,regex);
**** Warning: Non-local variable access here---------------------^
 204                                         
 205                                 ELSE
 206                                         res:=-1;
 207                                 END;
 208                                 
 209                                 WriteExit("MatchAtom result, ch ",res,rch.ch,-1);
 210                         END MatchAtom;
 211                         
 212                 BEGIN (*MatchPiece*) (*hier Matching-Procedures aufrufen piece.MatchProcQuantified(piece,flag)*)
 213                         (*MatchProcOptional (?)*)
 214                         WriteEntry("MatchPiece ",0X,-1);
 215                         IF sh.backTrack THEN RETURN END;
 216                         flag:=FALSE;
 217                         temp_flag:=FALSE;
 218                         q:=0;
 219                         (* get value of i, needed in repeat loops down case 2 and case 3 *)
 220                         i := sh.getSharedText().getParsePos();
 221                         CASE piece.id OF 
 222                                 1:  (* question mark, '?', optional *)
 223                                         WriteMessage("MatchPiece Case 1 Optional");
 224                                 
 225                                         atom:=piece.atom;   
 226                                         min:=0;
 227                                         max:=1;
 228                                         WriteMessage("MatchPiece Case 1 Optional vor MatchAtom");
 229                                         MatchAtom(atom,flag);
 230                                         IF sh.backTrack THEN RETURN END;
 231                                         IF ~flag THEN flag:=TRUE;
 232                                                 IF atom.regex=NIL THEN DEC(i) END
 233                                         END; 
 234                                         sh.getSharedText().setParsePos(i);
 235                 
 236                                 |2: (* repetitions, quantified (???) *)
 237                                         WriteMessage("MatchPiece Case 2 Quantifier ");
 238                                         atom:=piece.atom;   (*Quantified*)
 239                                         min:=piece.min.val;
 240                                         max:=piece.max.val;
 241                                         Console.WriteString("MatchPiece min");Console.WriteInt(min,2);
 242                                         Console.WriteString("MatchPiece max");Console.WriteInt(max,2);
 243                                         q:=0;
 244                                         
 245                                         
 246                                         j1:=i;
 247                                         REPEAT 
 248                                                 WriteMessage("MatchPiece Case 2 quantified in Repeat vor MatchAtom");
 249                                                 MatchAtom(atom,flag);
 250                                                 i:=sh.getSharedText().getParsePos();
 251                                                 IF sh.backTrack THEN 
 252                                                         WriteMessage("MatchPiece in Repeat sh.backTrack");
 253                                                         RETURN 
 254                                                 END;
 255                                                 IF flag THEN INC(q) END;
 256                                         UNTIL (~flag) OR (q=max);
 257                                         IF ~flag & (q>=min) THEN flag:=TRUE; 
 258                                                 IF atom.regex=NIL THEN DEC(i) END 
 259                                         END;
 260                                         sh.getSharedText().setParsePos(i);
 261                                         
 262                                 |3: (* asterisk('*' ) or plus('+') *)
 263                                         WriteMessage("MatchPiece Case 3 * or + ");
 264                                         atom:=piece.atom; (*Unbounded*) (*max=NIL*)
 265                                         temp_atom:=piece.suc.atom;
 266                                         min:=piece.min.val;
 267                                         REPEAT 
 268                                                 WriteMessage("MatchPiece case 3 * or + in Repeat vor MatchAtom 1");
 269                                                 MatchAtom(atom,flag);
 270                                                 IF sh.backTrack THEN RETURN END;
 271                                                 i:=sh.getSharedText().getParsePos();
 272                                                 (* j1: save increased i before decreasing;reset
 273                                                 parsePosition *)
 274                                                 j1:=i;
 275                                                 DEC(i); 
 276                                                 sh.getSharedText().setParsePos(i);
 277                                                 WriteMessage("MatchPiece case 3 * or + in Repeat vor MatchAtom 2");
 278                                                 
 279                                                 MatchAtom(temp_atom,temp_flag);
 280                                                 i := sh.getSharedText().getParsePos();
 281                                                 IF temp_atom.regex#NIL THEN i:=j1; 
 282                                                         sh.getSharedText().setParsePos(i);
 283                                                 END;
 284                                                 IF flag THEN INC(q) END;
 285                                                 IF temp_flag THEN DEC(q); flag:=FALSE END;
 286                                         UNTIL (~flag);
 287                                         IF ~flag & (q>=min) THEN flag:=TRUE; 
 288                                                 IF atom.regex=NIL THEN DEC(i) END 
 289                                         END;
 290                                         (*                                                        *)
 291                                         sh.getSharedText().setParsePos(i);
 292                 
 293                         END (*end-case*);
 294                         IF sh.backTrack THEN RETURN 
 295                         END;
 296                         IF flag THEN res:=1 ELSE res:=-1;
 297                         END;
 298                         
 299                         WriteExit("MatchPiece: ",res,rch.ch,i);
 300                 END MatchPiece; 
 301                 
 302                 PROCEDURE Final():BOOLEAN;
 303                 (* JR to be refined ? *)
 304                 BEGIN
 305                         IF sh.backTrack THEN RETURN FALSE END;
 306                         IF piece.suc=NIL THEN
**** ---------------------------^ Warning: Non-local variable access here
 307                                 IF piece.atom # NIL THEN
**** -----------------------------------^
**** Warning: Non-local variable access here
 308                                         IF piece.atom.range#NIL THEN
**** Warning: Non-local variable access here----^
 309                                                 IF (piece.atom.range.min=0X) & (piece.atom.range.max=0X) THEN RETURN TRUE;
**** Warning: Non-local variable access here-------------^
**** Warning: Non-local variable access here-----------------------------------------^
 310                                                 END;
 311                                         END;
 312                                 END;                                    
 313                         END;
 314                         RETURN FALSE;
 315                 END Final;
 316                 
 317         BEGIN (*MatchBranch*)
 318                 WriteEntry("MatchBranch ",0X,-1);
 319                 
 320                 piece:=branch.piece;
 321                 LOOP 
 322                         IF (piece=NIL) OR Final()(*JR*) THEN  EXIT; (*alle Pieces abgearbeitet und ganzen String*)
 323                         END;
 324                         WriteMessage("matchBranch vor MatchPiece in Loop");
 325                         MatchPiece(piece,flag);
 326                         WriteMessage("matchBranch nach MatchPiece in Loop");
 327                         IF sh.backTrack THEN RETURN 
 328                         END;
 329                         IF flag THEN  piece:=piece.suc; 
 330                                 
 331                         ELSE EXIT 
 332                         END;
 333                 END;
 334                 IF flag THEN res:=1 ELSE res:=-1;
 335                 END;
 336                 WriteExit("MatchBranch ch ",res,rch.ch,-1);
 337         END MatchBranch;
 338 
 339 (*TODO reset???*)
 340 BEGIN (*MatchRegex*)
 341         j:=i; (* save position *)
 342         WriteEntry("MatchRegex ch  i (= j): ",' ',i);
 343         branch:=regex.branch;
 344         
 345         LOOP
 346                 IF (branch=NIL) THEN EXIT END; 
 347                 MatchBranch(branch,flag);
 348                 IF sh.backTrack THEN RETURN END;
 349                 IF flag THEN EXIT;
 350                 ELSE 
 351                         
 352                         (*      
 353                                 Out.String("MatchRegex: Branch False  j= ");
 354                         Out.Int(j,2);Out.String("ch=");Out.Char(ch);Out.Ln();
 355                         
 356                         *)
 357                         
 358                         Console.WriteLn();Console.WriteString("MatchRegex Branch false j:");
 359                         Console.WriteInt(j,2);Console.WriteString(" ch=");
 360                         Console.Write(rch.ch);Console.WriteLn();
 361                         (* reset,
 362                         toDo parsePos*)
 363                         i:=j;
 364                         (*        ch:=tarString[i];     *)
 365                         (*****************
 366                         ch := GetCharAtPos(i,sh); 
 367                         ***************************)
 368                         (*sh.getCharAtTextPos(i);*)
 369                         IF sh.backTrack THEN RETURN END;
 370                         branch:=branch.alt
 371                 END
 372         END;
 373         IF flag THEN res:=1 ELSE res:=-1;END;
 374         WriteExit("MatchRegex ch ",res,rch.ch,i);
 375 END MatchRegex;
 376                                 
 377 PROCEDURE Match*(regex:RegexParser.Regex;target:POINTER TO ARRAY OF CHAR):BOOLEAN;
 378 VAR flag:BOOLEAN; branch:RegexParser.Branch;dummy:INTEGER;
 379 BEGIN
 380 
 381         (*___________________________________________
 382         (*tarString:=target;*)
 383         
 384         flag:=FALSE;
 385         i:=0;
 386         (*ch:=tarString[i];*)
 387         dummy:=0;
 388         MatchRegex(regex,dummy,flag);
 389         IF sh.backTrack THEN i:=0; RETURN FALSE END;
 390         IF ch#0X THEN (*ch:=tarString[i]*) ch:=0X; END;
 391         IF (flag) & (ch#0X) THEN flag:=FALSE END;
 392         RETURN flag
 393         -----------------------------------------*)
 394         RETURN FALSE;
 395 END Match; 
 396 
 397 (* called from ebnf-parser *)
 398 PROCEDURE EditMatch*(regex:RegexParser.Regex;shared:texts.Shared):BOOLEAN;
 399 VAR flag:BOOLEAN;
 400 BEGIN
 401         WriteEntry("RegexMatching.EditMatch ",0X,-1);
 402         flag:=FALSE;
 403         sh:=shared;
 404         
 405         i:=shared.getSharedText().getParsePos();
 406         
 407         Console.WriteString("RegexMatching.EditMatch i: ");
 408         Console.WriteInt(i,2);
 409         Console.WriteLn;
 410         (*ch:='$';*) (* GetCharAtPos(i,sh); shared.getCharAtTextPos(i);*)
 411         (*ch := shared.getSharedText().getTextCharAtPos(i);*)
 412         (*ch := shared.getSym();*) 
 413         (*******************************************)
 414         NEW(rch);       rch.ch:=' '; (*dummy*)
 415         (*Console.WriteString("RegexMatching.EditMatch ch: ");
 416         Console.Write(rch.ch);
 417         Console.WriteLn;*)
 418         Console.WriteString("RegexMatching.EditMatch TextLen: ");
 419         Console.WriteInt(shared.getSharedText().getTextLen(),2);
 420         Console.WriteLn;
 421         MatchRegex(regex,i,flag);
 422         IF sh.backTrack THEN i:=0; 
 423                 (* reset todo*)
 424                 RETURN FALSE; 
 425         END;
 426         RETURN flag;
 427         
 428 END EditMatch;
 429 
 430 
 431 
 432 END RegexMatching.

There were: No errors, and  10 warnings


