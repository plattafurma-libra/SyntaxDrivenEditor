Listing:

   1 MODULE RegexMatching;
   2 
   3 IMPORT RegexParser, texts, Console;
   4 
   5 TYPE Regex=POINTER TO EXTENSIBLE RECORD (RegexParser.RegexType) END;
   6 
   7 VAR i:INTEGER;
   8         ch:CHAR;
   9         (*tarString:POINTER TO ARRAY OF CHAR;*)
  10         sh:texts.Shared;
  11                 
  12 PROCEDURE WriteEntry(fromProcedure:ARRAY OF CHAR;ch:CHAR;i:INTEGER);
  13 
  14 
  15 BEGIN
  16         
  17         Console.WriteString(fromProcedure +" Entry:  ");                
  18         IF ch # 0X THEN Console.Write(ch);Console.WriteLn();
  19         END;
  20         IF i >= 0 THEN Console.WriteInt(i,2);
  21         END;
  22         Console.WriteLn();
  23 END WriteEntry;
  24 
  25 
  26 PROCEDURE WriteExit(fromProcedure:ARRAY OF CHAR;valResult:INTEGER;ch:CHAR;i:INTEGER);
  27 
  28 VAR res:ARRAY 10 OF CHAR; 
  29 BEGIN
  30         IF valResult=1  THEN res:="TRUE" ELSIF valResult=-1 THEN res:="FALSE" ELSE res:=""; END;
  31         Console.WriteString(fromProcedure +" Exit: "+res+"  ");         
  32         IF ch # 0X THEN Console.Write(ch);Console.WriteLn();
  33         END;
  34         IF i >= 0 THEN Console.WriteInt(i,2);
  35         END;
  36         Console.WriteLn();
  37 END WriteExit;
  38                 
  39 PROCEDURE GetCharAtPos(pos:INTEGER;sh:texts.Shared):CHAR;
  40 VAR ch:CHAR;
  41 
  42 BEGIN
  43         WriteEntry("GetCharAtPos pos",0X,pos);
  44         
  45         ch:= sh.getCharAtTextPos(pos);
  46         IF sh.backTrack THEN RETURN ' ' END;
  47         (* ch:= sh.getSym();
  48         IF pos < sh.texts.getTextLen() THEN
  49                         Console.WriteString("GetCharAtPos ch from sh.texts.getCharAtPos: ");
  50                         ch:= sh.texts.getCharAtPos(pos)
  51         ELSE 
  52                 Console.WriteString("GetCharAtPos ch from sh.getSym: ");
  53                 ch:= sh.getSym();
  54         END;*)  
  55         WriteExit("GetCharAtPos ch ",0,ch,-1);  
  56         RETURN ch;
  57 END GetCharAtPos;
  58 
  59 (*-------------------------Matching Procedures---------------------------*)
  60 
  61 PROCEDURE MatchNegRange(range:RegexParser.Range; VAR flag:BOOLEAN);
  62 BEGIN
  63         IF sh.backTrack THEN RETURN END;
  64         REPEAT
  65                 flag:=((ch<range.min) OR (ch>range.max));
  66                 range:=range.next;
  67         UNTIL range=NIL;
  68 END MatchNegRange;
  69 
  70 PROCEDURE MatchRange(range:RegexParser.Range; VAR flag:BOOLEAN);
  71 BEGIN
  72         WriteEntry("MatchRange ",ch,-1);
  73         IF sh.backTrack THEN RETURN END;
  74         LOOP
  75                 IF range=NIL THEN EXIT END;
  76                 Console.WriteString("MatchRange range.min, range.max: ");
  77                 Console.Write(range.min);Console.Write(' ');Console.Write(range.max);
  78                 Console.WriteLn();
  79                 flag:=((ch>=range.min) & (ch<=range.max));
  80                 IF flag=TRUE THEN EXIT;
  81                 ELSE range:=range.next END;
  82         END;
  83         (*jetzt noch schaun, ob irgendwo subRange *)
  84         LOOP
  85                 IF range=NIL THEN EXIT END;
  86                 IF range.sub THEN EXIT END;
  87                 range:=range.next
  88         END;
  89         IF range#NIL THEN MatchNegRange(range,flag) END;
  90         WriteExit("MatchRange ch ",0,ch,-1);
  91 END MatchRange;
  92 
  93 PROCEDURE MatchRegex(reg:RegexParser.Regex;VAR flag:BOOLEAN);
  94 VAR  branch:RegexParser.Branch;
  95                 j:INTEGER;
  96                 res:INTEGER;
  97         
  98         PROCEDURE MatchBranch(branch:RegexParser.Branch; VAR flag:BOOLEAN);
  99         VAR piece:RegexParser.Piece;
**** ------------^ Warning: This variable is accessed from nested procedure
**** Access to variable <piece> will be inefficient
 100         res:INTEGER;
 101         
 102                 PROCEDURE MatchPiece(piece:RegexParser.Piece; VAR flag:BOOLEAN);
 103                 VAR atom,temp_atom:RegexParser.Atom;
 104                                 min,max,q,j1:INTEGER;
 105                                 temp_flag:BOOLEAN;
 106                                 res:INTEGER;
 107                                 
 108                         PROCEDURE MatchAtom(atom:RegexParser.Atom; VAR flag:BOOLEAN);
 109                         VAR range:RegexParser.Range;res:INTEGER;
 110                         
 111                                 (*PROCEDURE Final():BOOLEAN;
 112                                 BEGIN
 113                                         IF (piece.suc = NIL) & (atom.range.min=0X) & (atom.range.max=0X) THEN RETURN TRUE
 114                                         ELSE RETURN FALSE;
 115                                         END;
 116                                 END Final;
 117                                 *)
 118                                 
 119                         BEGIN (* MatchAtom *)
 120                                 WriteEntry("MatchAtom ",ch,i);
 121                                 IF sh.backTrack THEN RETURN END;
 122                                 IF atom.range=NIL THEN  MatchRegex(atom.regex,flag);
 123                                 ELSE    (*         *)
 124                                         (*IF Final() THEN flag:=TRUE
 125                                         ELSE
 126                                                 *)
 127                                                 IF ~(ch=0X) THEN 
 128                                                         (*ch:=tarString[i];*)
 129                                                         ch:= GetCharAtPos(i,sh); (* sh.getCharAtTextPos(i);     *)              
 130                                                         IF sh.backTrack THEN RETURN END;                        
 131                                                         INC(i);
 132                                                         Console.WriteString("MatchAtom getCharAtTPos ch: ");
 133                                                         Console.Write(ch); 
 134                                                         Console.WriteLn();
 135                                                 END;                    
 136                                                 IF atom.range.pos THEN
 137                                                         MatchRange(atom.range,flag); 
 138                                                 ELSE MatchNegRange(atom.range,flag);
 139                                                 END;
 140                                         (*END;*)
 141                                 END;
 142                                 IF flag THEN res:=1 ELSE res:=-1;END;
 143                                 
 144                                 WriteExit("MatchAtom ch ",res,ch,-1);
 145                         END MatchAtom;
 146                         
 147                 BEGIN (*MatchPiece*) (*hier Matching-Procedures aufrufen piece.MatchProcQuantified(piece,flag)*)
 148                         (*MatchProcOptional (?)*)
 149                         WriteEntry("MatchPiece ",0X,-1);
 150                         IF sh.backTrack THEN RETURN END;
 151                         flag:=FALSE;temp_flag:=FALSE;q:=0;
 152                         CASE piece.id OF 
 153                                 1:  Console.WriteString("MatchPiece Case 1");Console.WriteLn();
 154                                 
 155                                         atom:=piece.atom;   (*Optional*)
 156                                         min:=0;
 157                                         max:=1;
 158                                         MatchAtom(atom,flag);
 159                                         IF sh.backTrack THEN RETURN END;
 160                                         IF ~flag THEN flag:=TRUE;
 161                                                 IF atom.regex=NIL THEN DEC(i) END
 162                                         END; 
 163                 
 164                 
 165                                 |2: Console.WriteString("MatchPiece Case 2");Console.WriteLn();
 166                                         atom:=piece.atom;   (*Quantified*)
 167                                         min:=piece.min.val;
 168                                         max:=piece.max.val;
 169                                         Console.WriteString("MatchPiece min");Console.WriteInt(min,2);
 170                                         Console.WriteString("MatchPiece max");Console.WriteInt(max,2);
 171                                         q:=0;
 172                                         j1:=i;
 173                                         REPEAT 
 174                                                 MatchAtom(atom,flag);
 175                                                 IF sh.backTrack THEN RETURN END;
 176                                                 IF flag THEN INC(q) END;
 177                                         UNTIL (~flag) OR (q=max);
 178                                         IF ~flag & (q>=min) THEN flag:=TRUE; 
 179                                                 IF atom.regex=NIL THEN DEC(i) END 
 180                                         END;
 181                 
 182                                 |3: Console.WriteString("MatchPiece Case 3");Console.WriteLn();
 183                                         atom:=piece.atom; (*Unbounded*) (*max=NIL*)
 184                                         temp_atom:=piece.suc.atom;
 185                                         min:=piece.min.val;
 186                                         REPEAT 
 187                                                 MatchAtom(atom,flag);
 188                                                 IF sh.backTrack THEN RETURN END;
 189                                                 j1:=i;DEC(i); MatchAtom(temp_atom,temp_flag);
 190                                                 IF temp_atom.regex#NIL THEN i:=j1 END;
 191                                                 IF flag THEN INC(q) END;
 192                                                 IF temp_flag THEN DEC(q); flag:=FALSE END;
 193                                         UNTIL (~flag);
 194                                         IF ~flag & (q>=min) THEN flag:=TRUE; 
 195                                                 IF atom.regex=NIL THEN DEC(i) END 
 196                                         END;
 197                 
 198                 
 199                         END (*end-case*);
 200                         IF sh.backTrack THEN RETURN END;
 201                         IF flag THEN res:=1 ELSE res:=-1;END;
 202                         
 203                         WriteExit("MatchPiece ch ",res,ch,i);
 204                 END MatchPiece; 
 205                 
 206                 PROCEDURE Final():BOOLEAN;
 207                 (* JR to be refined ? *)
 208                 BEGIN
 209                         IF sh.backTrack THEN RETURN FALSE END;
 210                         IF piece.suc=NIL THEN
**** ---------------------------^ Warning: Non-local variable access here
 211                                 IF piece.atom # NIL THEN
**** -----------------------------------^
**** Warning: Non-local variable access here
 212                                         IF piece.atom.range#NIL THEN
**** Warning: Non-local variable access here----^
 213                                                 IF (piece.atom.range.min=0X) & (piece.atom.range.max=0X) THEN RETURN TRUE;
**** Warning: Non-local variable access here-------------^
**** Warning: Non-local variable access here-----------------------------------------^
 214                                                 END;
 215                                         END;
 216                                 END;                                    
 217                         END;
 218                         RETURN FALSE;
 219                 END Final;
 220                 
 221         BEGIN (*MatchBranch*)
 222                 WriteEntry("MatchBranch ",0X,-1);
 223                 
 224                 piece:=branch.piece;
 225                 LOOP 
 226                         IF (piece=NIL) OR Final()(*JR*) THEN  EXIT; (*alle Pieces abgearbeitet und ganzen String*)
 227                         END;
 228                         MatchPiece(piece,flag);
 229                         IF sh.backTrack THEN RETURN END;
 230                         IF flag THEN  piece:=piece.suc; 
 231                                 
 232                         ELSE EXIT 
 233                         END;
 234                 END;
 235                 IF flag THEN res:=1 ELSE res:=-1;END;
 236                 WriteExit("MatchBranch ch ",res,ch,-1);
 237         END MatchBranch;
 238 
 239 BEGIN (*Match Regex*)
 240         j:=i;
 241         WriteEntry("MatchRegex ch  i and j: ",ch,i);
 242         branch:=reg.branch;
 243         
 244         LOOP
 245                 IF (branch=NIL) THEN EXIT END; 
 246                 MatchBranch(branch,flag);
 247                 IF sh.backTrack THEN RETURN END;
 248                 IF flag THEN EXIT;
 249                 ELSE 
 250                         
 251                         (*      Out.String("MatchRegex: Branch False  j= ");
 252                         Out.Int(j,2);Out.String("ch=");Out.Char(ch);Out.Ln();*)
 253                         Console.WriteLn();Console.WriteString("MatchRegex Branch false j:");
 254                         Console.WriteInt(j,2);Console.WriteString(" ch=");
 255                         Console.Write(ch);Console.WriteLn();
 256                         i:=j;
 257                         (*ch:=tarString[i];*)
 258                         ch := GetCharAtPos(i,sh); (*sh.getCharAtTextPos(i);*)
 259                         IF sh.backTrack THEN RETURN END;
 260                         branch:=branch.alt
 261                 END
 262         END;
 263         IF flag THEN res:=1 ELSE res:=-1;END;
 264         WriteExit("MatchRegex ch ",res,ch,i);
 265 END MatchRegex;
 266                                 
 267 PROCEDURE Match*(regex:RegexParser.Regex;target:POINTER TO ARRAY OF CHAR):BOOLEAN;
 268 VAR flag:BOOLEAN; branch:RegexParser.Branch;
 269 BEGIN
 270         (*tarString:=target;*)
 271         
 272         flag:=FALSE;
 273         i:=0;
 274         (*ch:=tarString[i];*)
 275         MatchRegex(regex,flag);
 276         IF sh.backTrack THEN i:=0; RETURN FALSE END;
 277         IF ch#0X THEN (*ch:=tarString[i]*) ch:=0X; END;
 278         IF (flag) & (ch#0X) THEN flag:=FALSE END;
 279         RETURN flag
 280 END Match; 
 281 
 282 
 283 PROCEDURE EditMatch*(regex:RegexParser.Regex;shared:texts.Shared):BOOLEAN;
 284 VAR flag:BOOLEAN;
 285 BEGIN
 286         WriteEntry("EditMatch ",0X,-1);
 287         
 288         flag:=FALSE;
 289         sh:=shared;
 290         (*i:=shared.texts.getTextPos();*)
 291         Console.WriteString("RegexMatching.EditMatch i: ");
 292         Console.WriteInt(i,2);
 293         Console.WriteLn;
 294         (*ch:='$';*) (* GetCharAtPos(i,sh); shared.getCharAtTextPos(i);*)
 295         Console.WriteString("RegexMatching.EditMatch ch: ");
 296         Console.Write(ch);
 297         Console.WriteLn;
 298         Console.WriteString("RegexMatching.EditMatch TextLen: ");
 299         Console.WriteInt(shared.getSharedText().getTextLen(),2);
 300         Console.WriteLn;
 301         MatchRegex(regex,flag);
 302         IF sh.backTrack THEN i:=0; RETURN FALSE END;
 303         RETURN flag;
 304 END EditMatch;
 305 
 306 
 307 PROCEDURE GetStartCh*(shared:texts.Shared);
 308 BEGIN
 309         ch:=shared.getSym();
 310         WriteEntry("GetStartCh: ",ch,-1);
 311         i:=0;
 312 END GetStartCh;
 313 
 314 
 315 
 316 
 317 END RegexMatching.

There were: No errors, and  6 warnings


