Listing:

   1 MODULE Ebnf;
   2 
   3 
   4 
   5 
   6 (* code mainly from Niklaus Wirth Grundlagen und Techniken des Compilerbaus, from English
   7 version Compiler Construction, too (s. http://www.ethoberon.ethz.ch/WirthPubl/CBEAll.pdf) and for more implementation
   8 details from Wirth Compilerbau Stuttgart Teubner 1986 (for Modula 2).
   9 Changes by JR;
  10 Parser is rewritten to be completely recursive for to establish unlimited backtracking in parse.
  11 *)
  12 
  13 
  14 (* Wirth example: ebnf defined in ebnf
  15 syntax        =     {production}.           
  16 production    =     identifier "=" expression "." . 
  17 expression    =     term {"|" term}. 
  18 term          =     factor {factor}.              
  19 factor        =     identifier | string | "(" expression ")"
  20  | "[" expression "]" | "{" expression "}". 
  21 By application of the given translation rules and subsequent simplification the following parser 
  22 results. It is formulated as an Oberon module: 
  23 *)
  24 
  25 
  26  
  27 IMPORT RTS,TextsCP, texts, Console, RegexApi, RegexMatching,RegexParser,CPmain; 
  28 
  29 CONST IdLen = 32; 
  30     ident = 0; literal = 2; lparen = 3; lbrak = 4; lbrace = 5; bar = 6; eql = 7; 
  31     rparen = 8; rbrak = 9; rbrace = 10; period = 11; other = 12; 
  32     
  33 TYPE Identifier = ARRAY IdLen OF CHAR; 
  34 
  35      Symbol*=POINTER TO EXTENSIBLE RECORD alt,next:Symbol 
  36      END;
  37      
  38      Terminal=POINTER TO RECORD(Symbol) sym:INTEGER;name:ARRAY IdLen OF CHAR; 
  39         reg:RegexApi.Regex;
  40      END;
  41      
  42      Nonterminal = POINTER TO NTSDesc;
  43          NTSDesc = RECORD (Symbol) this: Header END;
  44          Header = POINTER TO HDesc;
  45          HDesc = RECORD sym: Symbol; entry: Symbol; suc:Header; name: ARRAY IdLen OF CHAR END;
  46               
  47 VAR list,sentinel,h:Header;
  48         q,r,s: Symbol;
  49         startsymbol*:Symbol (* startsymbol for parse if called from editor, is exported to call of parse procedure*);
  50 
  51         ch: CHAR;       
  52     sym:      INTEGER;       
  53     lastpos:  INTEGER;       
  54     id:       Identifier;       
  55     R:        TextsCP.Reader;       
  56     W:        TextsCP.Writer;       
  57    
  58     txt:texts.Texts;
  59     shared:texts.Shared;
  60     
  61   
  62 PROCEDURE error(n: INTEGER); 
  63               VAR pos: INTEGER;       
  64 BEGIN pos := TextsCP.Pos(R); 
  65         Console.WriteString("error nr: ");Console.WriteInt(n,2);Console.WriteLn;
  66     IF pos > lastpos+4 THEN  (*avoid spurious error messages*) 
  67         TextsCP.WriteString(W, "  pos"); TextsCP.WriteInt(W, pos, 6); 
  68         TextsCP.WriteString(W, "  err"); TextsCP.WriteInt(W, n, 4); lastpos := pos; 
  69         TextsCP.WriteString(W,"sym"); TextsCP.WriteInt(W, sym, 4); 
  70         TextsCP.WriteLn(W);   (* TextsCP.Append(Oberon.Log,W.buf)   *) 
  71     END;
  72     RTS.Throw(" error");       
  73 END error;     
  74 
  75 PROCEDURE GetSym; 
  76 VAR i:INTEGER;       
  77 BEGIN 
  78         WHILE ~R.eot & (ch <= " ") DO TextsCP.Read(R, ch) END ;   (*skip blanks*) 
  79     CASE ch OF       
  80                 "A" .. "Z", "a" .. "z": sym := ident; i := 0; 
  81                         REPEAT id[i] := ch; INC(i); TextsCP.Read(R, ch) 
  82                         UNTIL (CAP(ch) < "A") OR (CAP(ch) > "Z"); 
  83             id[i]:=0X       
  84                         |22X:  (*quote*) 
  85                                 TextsCP.Read(R, ch); sym := literal; i := 0; 
  86                                 (* wirth----------------------------------- 
  87                                 WHILE (ch # 22X) & (ch > " ") DO 
  88                     id[i]:= ch;
  89                     INC(i);
  90                     TextsCP.Read(R,ch)       
  91                                 END ; 
  92                                 IF ch <= " " THEN error(1) END ; 
  93                                 ------------------------------------------*)
  94                                 (* JR, regex *)
  95                                 LOOP
  96                                         IF ch=22X THEN
  97                                                 IF i=0 (*empty terminal string*) THEN EXIT
  98                                                 ELSIF id[i] # '\'  (* quote is NOT escaped *) THEN EXIT
  99                                                 ELSIF (i >0) & (id[i-1] = '\') (* '\' is escaped by '\', 
 100                                                 i.e. termination by '"'*)
 101                                                                 THEN EXIT
 102                                                 END;
 103                                         END;
 104                                     id[i]:= ch;
 105                     INC(i);
 106                     IF i > IdLen THEN error(1);
 107                     END;
 108                     TextsCP.Read(R,ch)       
 109                                 END ; 
 110                                 (* Wirth IF ch <= " " THEN error(1) END ;       *)
 111                                 id[i] := 0X; TextsCP.Read(R, ch) 
 112                         |  "=" : sym := eql; TextsCP.Read(R, ch) 
 113                         |  "(" : sym := lparen; TextsCP.Read(R, ch) 
 114                         |  ")" : sym := rparen; TextsCP.Read(R, ch) 
 115                         |  "[" : sym := lbrak; TextsCP.Read(R, ch) 
 116                         |  "]" : sym := rbrak; TextsCP.Read(R, ch) 
 117                         | "{" : sym := lbrace; TextsCP.Read(R, ch) 
 118                         |  "}" : sym := rbrace; TextsCP.Read(R, ch) 
 119                         | "|" : sym := bar; TextsCP.Read(R, ch) 
 120                         |  "." : sym := period; TextsCP.Read(R, ch) 
 121                         ELSE sym := other; 
 122                                 (* if entered by jr; otherwise eof error*)
 123                                 IF R.eot THEN ch:=' ' ELSE TextsCP.Read(R, ch);END; 
 124                 END       
 125 END GetSym; 
 126 
 127  
 128 PROCEDURE find(str : ARRAY OF CHAR; VAR h:Header);
 129 VAR h1:Header;
 130 BEGIN
 131         h1:=list;
 132         sentinel.name:=str$;
 133         WHILE h1.name#str DO h1:=h1.suc;END;
 134         IF h1 = sentinel THEN (*insert*)
 135                 NEW(sentinel);
 136                 h1.suc := sentinel;
 137                 h1.entry:=NIL;
 138         END;    
 139         h:=h1;
 140 END find;
 141 
 142 PROCEDURE link(p,q:Symbol);
 143 VAR t:Symbol;
 144 
 145 BEGIN (* insert q in places indicated by linked chain p *)
 146         WHILE p # NIL DO
 147                 t := p; p:=t.next; t.next:=q;
 148         END;
 149 END link;
 150    
 151 
 152 PROCEDURE expression(VAR p,q,r,s:Symbol);   
 153 VAR q1, s1:Symbol;
 154 
 155     
 156     PROCEDURE term(VAR p,q,r,s:Symbol);  
 157     VAR p1,q1,r1,s1:Symbol;     
 158 
 159        PROCEDURE factor(VAR p,q,r,s:Symbol);    
 160        VAR a:Symbol;identifiernonterminal:Nonterminal;literalterminal:Terminal; h:Header;
 161        BEGIN h:=NIL;a:=NIL;identifiernonterminal:=NIL;literalterminal:=NIL;                     
 162             IF sym = ident (*nonterminal*) THEN
 163                 NEW(identifiernonterminal);
 164                 find(id$,h);
 165                 (* name of nonterminal symbol may be accessed via h.name);*)
 166                 identifiernonterminal.this:=h;
 167                 a:=identifiernonterminal;a.alt:=NIL;a.next:=NIL;
 168                 
 169                 (*record(T0, id, 1);*)  
 170                 p:=a;q:=a;r:=a;s:=a;           
 171                 GetSym 
 172             ELSIF sym = literal (*terminal*) THEN 
 173                 NEW(literalterminal);literalterminal.sym:=sym;
 174                 literalterminal.name:=id$; 
 175                 literalterminal.reg:=RegexApi.CreateRegex(id$);
 176                 a:=literalterminal;a.alt:=NIL;a.next:=NIL;
 177                 (*record(T1, id, 0);*) 
 178                 
 179                 p:=a;q:=a;r:=a;s:=a; 
 180                 GetSym 
 181             ELSIF sym = lparen THEN 
 182                         GetSym; 
 183                         expression(p,q,r,s); 
 184                 IF sym = rparen THEN GetSym ELSE error(2) END 
 185             ELSIF sym = lbrak THEN 
 186                         GetSym; expression(p,q,r,s); 
 187                         
 188                         NEW(literalterminal);literalterminal.sym:=sym;
 189                 literalterminal.name:=""; 
 190                 a:=literalterminal;a.alt:=NIL;a.next:=NIL;
 191                 q.alt:=a;s.next:=a;q:=a;s:=a;
 192                 IF sym = rbrak THEN GetSym ELSE error(3) END 
 193             ELSIF sym = lbrace THEN 
 194                         GetSym; expression(p,q,r,s); 
 195                         
 196                         NEW(literalterminal);literalterminal.sym:=sym;
 197                 literalterminal.name:=""; 
 198                 a:=literalterminal;a.alt:=NIL;a.next:=NIL;
 199                         q.alt:=a;q:=a;r:=a;s:=a;
 200                 IF sym = rbrace THEN GetSym ELSE error(4) END 
 201             ELSE    error(5)    
 202                 END;            
 203         END factor;    
 204  
 205     
 206      BEGIN (*term*) 
 207         p1:=NIL;q1:=NIL;r1:=NIL;s1:=NIL;        
 208         factor(p,q,r,s);           
 209         WHILE sym < bar DO 
 210                 factor(p1,q1,r1,s1);link(r,p1);r:=r1;s:=s1; 
 211         END;            
 212        
 213      END term; 
 214            
 215     BEGIN (*expression*)  
 216         q1:=NIL;s1:=NIL;  
 217         
 218         term(p,q,r,s);      
 219         WHILE sym = bar DO GetSym; term(q.alt,q1,s.next,s1);q:=q1;s:=s1; 
 220         END;    
 221         
 222     END expression;
 223  
 224 
 225            
 226 PROCEDURE production;       
 227 BEGIN (*sym = ident*) 
 228         
 229         find(id$,h);
 230         GetSym; 
 231     IF sym = eql THEN GetSym ELSE error(7) END; 
 232     expression(h.entry,q,r,s); link(r,NIL);   
 233     IF sym = period THEN 
 234         GetSym
 235     ELSE error(8) 
 236     END;
 237      
 238 END production;
 239 
 240 
 241       
 242 PROCEDURE syntax;       
 243 BEGIN           
 244         TextsCP.WriteStringLn("syntax start");
 245     WHILE sym = ident DO production END;  
 246     TextsCP.WriteStringLn("syntax end"); 
 247 END syntax;  
 248 
 249 (* checks whether there is a nonterminalwhich does not lead to a terminal*)
 250 PROCEDURE checkSyntax():BOOLEAN;
 251 VAR h:Header;error:BOOLEAN;(*i:INTEGER;*)
 252 BEGIN
 253         Console.WriteLn();
 254         h:=list;error:=FALSE;
 255         WHILE h # sentinel DO   
 256                 IF h.entry=NIL THEN 
 257                         error:=TRUE;
 258                         Console.WriteString("undefined Symbol "+h.name);Console.WriteLn();
 259                 ELSE Console.WriteString("Symbol "+h.name);Console.WriteLn();
 260                         (*i:=0;
 261                         WHILE h.name[i]#0X DO Console.Write(h.name[i]);INC(i);END;Console.WriteLn();
 262                         *)
 263                 END;
 264                 h:=h.suc;
 265         END (*while*);
 266         RETURN ~error;
 267 END checkSyntax;
 268             
 269 PROCEDURE Compile*():BOOLEAN; 
 270 VAR ok:BOOLEAN;
 271 BEGIN (*set R to the beginning of the text to be compiled*) 
 272         TextsCP.WriteString(W,"Compile Start read Grammar");Console.WriteLn();
 273         R.filename:= "C://users//rols//lexGrammar.txt"; 
 274         TextsCP.OpenReader(R);
 275         Console.WriteString("EBNF nach OpenReader");Console.WriteLn();  
 276         
 277         ok:=FALSE;
 278     lastpos := 0; 
 279     NEW(sentinel);list:=sentinel;h:=list;
 280     TextsCP.Read(R, ch); 
 281     GetSym;
 282     syntax;  
 283     IF checkSyntax() THEN ok:=TRUE;
 284     END;   
 285     (*TextsCP.Append(Oberon.Log,W.buf) *)   
 286     IF ok THEN
 287         TextsCP.WriteString(W,"Compile ok")
 288     ELSE TextsCP.WriteString(W,"Compile failed");
 289     END;
 290     Console.WriteLn(); 
 291     RETURN ok; 
 292 END Compile;    
 293 
 294 
 295 PROCEDURE parse*(node:Symbol):BOOLEAN;
 296 
 297 VAR res:BOOLEAN; pos:INTEGER;
 298 
 299                 PROCEDURE match(tNode:Terminal):BOOLEAN;
 300         
 301                 VAR index:INTEGER;ch:CHAR;testChar:CHAR;testBool:BOOLEAN;
 302         
 303                 (*          *)
 304                 BEGIN
 305                         Console.WriteString("parse.match Start pos: ");
 306                         Console.WriteInt(txt.getTextPos(),2);
 307                         Console.WriteString(" "+tNode.name$);
 308                         Console.WriteLn();
 309                         index:=0;
 310                                                 
 311                         testBool:=RegexMatching.EditMatch(tNode.reg.regex,shared);
 312                         IF testBool THEN 
 313                                 Console.WriteString(" nach EditMatch testBool true");
 314                         ELSE
 315                                 Console.WriteString(" nach EditMatch testBool false");
 316                         END;
 317                         Console.WriteLn();
 318                         (*
 319                         WHILE tNode.name[index] # 0X DO
 320                                 (* editor or File *)
 321                                 IF editorOrFile THEN
 322                                         ch:=shared.getSym();
 323                                         (* test *)
 324                                         testChar:=shared.getCharAtTextPos(0);
 325                                         Console.WriteString("testChar: ");
 326                                         Console.Write(ch);
 327                                         Console.WriteLn();
 328                                                                                 
 329                                 ELSE
 330                                         ch:= txt.getTextChar();
 331                                 END;
 332                                 IF tNode.name[index] # ch THEN
 333                                         Console.WriteString("match failed ");
 334                                         Console.WriteLn();
 335                                         RETURN FALSE;
 336                                 ELSE
 337                                         Console.Write(ch);
 338                                         INC(index);
 339                                 END;
 340                         END (* While*);
 341                         *)
 342                         Console.WriteLn();
 343                         Console.WriteString("match ok for "+tNode.name$);
 344                         (*Console.WriteInt(txt.getTextPos(),2);*) Console.WriteLn();
 345                         RETURN TRUE;
 346                                                 
 347                 END match;
 348         
 349         
 350 
 351 BEGIN (*parse*)
 352         IF shared.backTrack THEN
 353                 IF node#list.entry THEN RETURN FALSE
 354                 ELSE
 355                         txt.setTextPos(0);
 356                         Console.WriteString("parse after backtrack restart");Console.WriteLn();
 357                         shared.backTrack=false;
**** error in IdentStatement-----------------^
**** Identifier not known in this scope-------^
 358                 END;
 359         END;
 360         Console.WriteString("parse (*hd.name: *)"(*+hd.name*));Console.WriteLn();
 361         pos:=txt.getTextPos();
 362         res:=FALSE;     
 363         IF node = NIL THEN RETURN TRUE
 364         ELSIF node IS Terminal THEN
 365                         res:=match(node(Terminal));
 366                         Console.WriteString("parse res after MatchProc: ");
 367                         Console.WriteInt(txt.getTextPos(),2);Console.WriteLn();                 
 368                 (* depth first recursion for nonterminal *)
 369         ELSE res:=parse(node(Nonterminal).this(*pointer to headerlist*).entry);
 370         END;
 371         
 372         (* bredth second recursion*)
 373         IF res THEN res:=parse(node.next);
 374                 IF res THEN RETURN TRUE;
 375                 END;
 376         END;
 377         
 378         (* alternative after fail, reset position in text *)
 379         txt.setTextPos(pos);
 380         (* no alt node is fail; if needed for distinction of case of empty node which is matched
 381                 without change of pos*)
 382         IF node.alt=NIL THEN RETURN FALSE
 383         ELSIF parse(node.alt) THEN RETURN TRUE
 384         ELSE txt.setTextPos(pos);RETURN FALSE;          
 385         END;
 386         
 387 END parse;
 388 
 389 
 390 PROCEDURE init*(sh:texts.Shared):BOOLEAN;
 391 
 392 BEGIN
 393         Console.WriteString("Init entry");Console.WriteLn();    
 394         IF Compile() THEN               
 395                 Console.WriteString("nach Compile");Console.WriteLn();                  
 396                 startsymbol:=list.entry;
 397                 shared:=sh;
 398                 txt:=shared.getSharedText();(* for getTextPos and setTextPos access*)
 399                 RegexMatching.GetStartCh(sh);
 400                 
 401                 RETURN TRUE;
 402         ELSE RETURN FALSE;
 403         END;
 404 END init;
 405 
 406 BEGIN (*Auto-generated*)
 407         shared:=NIL;txt:=NIL;startsymbol:=NIL;
 408         Console.WriteString("EBNF Start ");Console.WriteLn();
 409         
 410                 
 411         IF init(shared) THEN            
 412                 Console.WriteString("EBNF nach Init");Console.WriteLn();                        
 413                 (*  *)
 414                 (*txt:=shared.texts;*)
 415                 
 416                 IF parse(list.entry(* before: list only *)) THEN
 417                         Console.WriteString(" parse ok")
 418                 ELSE Console.WriteString(" parse failed");
 419                 END;
 420                 
 421         END;
 422         
 423         
 424         Console.WriteString("EBNF End");Console.WriteLn();
 425 END Ebnf.

There were:  2 errors, and No warnings


